/*
Navicat MySQL Data Transfer

Source Server         : localhost_3306
Source Server Version : 50524
Source Host           : localhost:3306
Source Database       : my_vue_blog

Target Server Type    : MYSQL
Target Server Version : 50524
File Encoding         : 65001

Date: 2019-03-09 17:32:31
*/

SET FOREIGN_KEY_CHECKS=0;

-- ----------------------------
-- Table structure for category
-- ----------------------------
DROP TABLE IF EXISTS `category`;
CREATE TABLE `category` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(100) DEFAULT NULL COMMENT '文章分类名称',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=20 DEFAULT CHARSET=utf8 COMMENT='文章分类表';

-- ----------------------------
-- Records of category
-- ----------------------------
INSERT INTO `category` VALUES ('14', 'nodejs');
INSERT INTO `category` VALUES ('15', 'koa');
INSERT INTO `category` VALUES ('16', 'js');
INSERT INTO `category` VALUES ('17', 'vue');
INSERT INTO `category` VALUES ('18', 'axios');
INSERT INTO `category` VALUES ('19', 'css3');

-- ----------------------------
-- Table structure for draft_post_redis
-- ----------------------------
DROP TABLE IF EXISTS `draft_post_redis`;
CREATE TABLE `draft_post_redis` (
  `id` int(11) unsigned NOT NULL AUTO_INCREMENT,
  `redisKey` varchar(100) DEFAULT NULL,
  `postId` int(11) DEFAULT NULL,
  `title` varchar(200) DEFAULT NULL,
  `content` text,
  `categoryId` int(11) DEFAULT NULL,
  `poster` varchar(200) DEFAULT NULL,
  `tags` varchar(200) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of draft_post_redis
-- ----------------------------

-- ----------------------------
-- Table structure for laboratory
-- ----------------------------
DROP TABLE IF EXISTS `laboratory`;
CREATE TABLE `laboratory` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(100) DEFAULT NULL COMMENT '项目名称',
  `description` varchar(1000) DEFAULT NULL COMMENT '项目说明',
  `link` varchar(500) DEFAULT NULL COMMENT '项目地址',
  `poster` varchar(500) DEFAULT NULL COMMENT '项目海报',
  `createTime` datetime DEFAULT NULL COMMENT '创建时间',
  `github` varchar(500) DEFAULT NULL COMMENT '项目Github地址',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=23 DEFAULT CHARSET=utf8 COMMENT='实验室表，记录个人项目';

-- ----------------------------
-- Records of laboratory
-- ----------------------------
INSERT INTO `laboratory` VALUES ('20', '这是一个测试实验室项目123123', '测试测试', 'https://github.com/dirkhe1051931999', '\\uploads\\20190309\\1552123814881.png', '2019-03-09 17:30:43', 'https://github.com/dirkhe1051931999');
INSERT INTO `laboratory` VALUES ('21', '这是一个测试实验室项目', '测试测试', 'https://github.com/dirkhe1051931999', '\\uploads\\20190309\\1552123834217.png', '2019-03-09 17:30:34', 'https://github.com/dirkhe1051931999');
INSERT INTO `laboratory` VALUES ('22', '这是一个测试实验室项目', '测试测试', 'https://github.com/dirkhe1051931999', '\\uploads\\20190309\\1552123848025.png', '2019-03-09 17:30:48', 'https://github.com/dirkhe1051931999');

-- ----------------------------
-- Table structure for post
-- ----------------------------
DROP TABLE IF EXISTS `post`;
CREATE TABLE `post` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `title` varchar(200) DEFAULT NULL COMMENT '文章标题',
  `content` text COMMENT '文章内容',
  `categoryId` int(11) DEFAULT NULL COMMENT '文章分类表主键',
  `status` enum('DRAFT','PUBLISHED','OFFLINE') DEFAULT NULL COMMENT '文章状态(DRAFT: 草稿， PUBLISHED: 发布，OFFLINE: 下线)',
  `poster` varchar(200) DEFAULT NULL COMMENT '海报图片',
  `createTime` datetime DEFAULT NULL COMMENT '创建时间',
  `viewTotal` int(11) DEFAULT NULL COMMENT '文章查看次数',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=42 DEFAULT CHARSET=utf8 COMMENT='文章表';

-- ----------------------------
-- Records of post
-- ----------------------------
INSERT INTO `post` VALUES ('29', 'nodejs 熟悉,http,fs,path,Buffer 的使用', '## nodejs、express、koa搭建服务器\n+ node\n```js\nlet http = require(\"http\");\nlet server = http.createServer(function (req, res) {\n  res.writeHead(200, {\n    \'Content-Type\': \"text/html\"\n  });\n  res.end(\'<h1>hello nodejs</h1>\')\n})\nserver.listen(1111);\n```\n+ express\n```js\nlet express = require(\'express\');\nlet app = express();\napp.get(\'/\', function (req, res) {\n  res.send(\'<h1>Hello express!</h1>\');\n});\n\napp.listen(1111, function () {\n  console.log(\'Example app listening on port 1111!\');\n});\n```\n+ koa\n```js\nconst Koa = require(\"koa\");\nconst app = new Koa();\napp.use(async (ctx) => {\n  ctx.body = \"hello koa\"\n})\napp.listen(1111, function () {\n  console.log(\'Example app listening on port 1111!\');\n})\n```\n## 文件服务器\n```js\nlet fs = require(\'fs\');\nlet url = require(\'url\');\nlet path = require(\"path\");\nlet http = require(\"http\");\nlet root = path.resolve(process.argv[2] || \".\")\nlet server = http.createServer((req, res) => {\n  let pathname = url.parse(req.url).pathname;\n  let filepath = path.join(root, pathname);\n  fs.stat(filepath, (err, stats) => {\n    if (!err && stats.isFile()) {\n      console.log(\"200\" + req.url);\n      res.writeHead(200);\n      fs.createReadStream(filepath).pipe(res)\n    } else {\n      console.log(404);\n      res.writeHead(404);\n      res.end(\"404 not found\")\n    }\n  })\n})\nserver.listen(1111)\n```\n## 文件复制\n```js\nlet fs = require(\"fs\");\nfunction copyFile(src, dist) {\n  fs.writeFileSync(dist, fs.readFileSync(src));\n}\ncopyFile(\"./a.txt\", \'./aa.txt\');\n```\n```js\nlet fs = require(\"fs\");\nfunction copyFile(src, dist) {\n  fs.createReadStream(src).pipe(fs.createWriteStream(dist));\n}\ncopyFile(\"./a.txt\", \'./aaa.txt\');\n```\n## 文件夹里文件复制\n```js\nlet fs = require(\"fs\");\nfunction copyDir(src, dist, callback) {\n  fs.access(dist, function (err) {\n    if (err) {\n      fs.mkdirSync(dist)\n    }\n    _copy(null, src, dist)\n  });\n  function _copy(err, src, dist) {\n    if (err) {\n      callback(err)\n    } else {\n      fs.readdir(src, function (err, paths) {\n        if (err) {\n          callback(err);\n        } else {\n          paths.forEach(function (path) {\n            let _src = src + \"/\" + path;\n            let _dist = dist + \"/\" + path;\n            fs.stat(_src, function (err, stat) {\n              if (err) {\n                callback(err)\n              } else {\n                if (stat.isFile()) {\n                  fs.createReadStream(_src).pipe(fs.createWriteStream(_dist));\n                } else if (stat.isDirectory()) {\n                  copyDir(_src, _dist, callback)\n                }\n              }\n            })\n          })\n        }\n      })\n    }\n  }\n}\ncopyDir(\'./test\', \'./test2\', function (err) {\n  if (err) {\n    console.log(err);\n  }\n})\n```\n## 遍历文件夹下文件\n```js\nlet fs = require(\"fs\");\nlet join = require(\"path\").join;\nfunction getJsonFiles(jsonPath) {\n  let jsonFiles = [];\n  function findJsonFile(path) {\n\n    let files = fs.readdirSync(path);\n    files.forEach(function (item, index) {\n      let fPath = join(path, item);\n      let _file = item;\n      let stat = fs.statSync(fPath);\n      if (stat.isDirectory()) {\n        findJsonFile(fPath)\n      }\n      if (stat.isFile()) {\n        jsonFiles.push(fPath)\n      }\n    })\n  }\n  findJsonFile(jsonPath)\n  console.log(jsonFiles)\n}\ngetJsonFiles(\"test\")\n```\n', '14', 'PUBLISHED', '', '2019-03-09 17:20:37', '0');
INSERT INTO `post` VALUES ('30', 'koa的原理与koa-static koa-router等中间件的实现', '## koa的原理与koa-static koa-router等中间件的实现\n\n### koa的原理与洋葱模型\n+ koa是什么\n\n	express原班人马开发的极简web框架，为什么称为极简，因为只做了4件事\n	\n	1. 处理HTTP的request\n	2. 处理http的response\n	3. 中间件的加载\n	4. 中间件的执行\n\n	所以我们在使用koa开发时，只需要做两件事：1、框架的设计2、中间件的选择\n+ koa的文件结构\n	1. application.js 封装了context，request，response，中间件处理流程\n	2. context.js 处理应用上下文\n	3. request.js 处理http请求\n	4. resonse.js 处理http响应\n	\n+ koa的异步处理\n\n	koa是基于async/await操作中间件，node版本需要大于7 他是async/await generator/yield的衍生，但本质还是Promise\n+ koa的AOP设计\n	+ APO设计：面向切面编程\n	+ 面向切面编程：在程序或者声明周期中，加入或减去一个或多个功能，不影响原有功能\n	+ koa的切面：使用中间件实现，一个中间件有两个切面，切面执行顺序，类似栈，先进后出\n	+ koa是洋葱模型HTTP中间件处理流程，处理流程就像剥洋葱，按照生命周期，执行中间件，有前置操作、其他操作和后置操作\n	+ koa的切面\n	![koa的洋葱切面](https://github.com/dirkhe1051931999/hjBlog/blob/master/blog-management/screenshot/aop.png)\n+ 代码实现\n```js\nlet context = {}\nasync function m1(ctx,next){\n  console.log(\'1\')\n  await next();\n  console.log(\'2\')\n}\nasync function m2(ctx,next){\n  console.log(\'3\')\n  await next();\n  console.log(\'4\')\n}\nasync function m3(ctx,next){\n  console.log(\'5\')\n  await next();\n  console.log(\'6\')\n}\nPromise.resolve(m1(context,async()=>{\n  return Promise.resolve(m2(context,async()=>{\n    return Promise.resolve(m3(context,async()=>{\n      return Promise.resolve();\n    }))\n  }))\n})).then(()=>{\n  console.log(\"end\");\n})\n```\n输出的值分别是 1 3 5 6 4 2 ，其中生命周期就是Promise 中间件是m1 m2 m3 next前为前置操作，next后为后置操作，类似一个大回环，先前置操作的最后后置操作，就是这个道理\n### koa的服务器搭建\n上篇博客里已经介绍了koa如何开启服务器，这里面就不说了，可以看上篇[nodejs熟悉,http,fs,path,Buffer的使用](https://github.com/dirkhe1051931999/hjBlog/blob/master/blog-management/lessons/01.md)\n### koa通过use导入中间件\n```js\n// log.js\nfunction log(ctx) {\n  console.log(ctx)\n}\nmodule.exports = function () {\n  return async function (ctx, next) {\n    log(ctx)\n    await next()\n  }\n}\n// index.js\nconst Koa  = require(\"koa\");\nconst Log = require(\"./logger\");\nconst app = new Koa();\napp.use(Log())\napp.use((ctx)=>{\n  ctx.body = \"hello world\"\n})\napp.listen(1111)\n```\n### koa实现自定义路由\n- 访问127.0.0.1:1111\n```js\nconst Koa = require(\"koa\");\nconst fs = require(\"fs\")\nconst app = new Koa();\n\nfunction render(page) {\n  return new Promise((resolve, reject) => {\n    let ViewUrl = `./test/${page}`;\n    fs.readFile(ViewUrl, \'binary\', (err, data) => {\n      if (err) {\n        reject(err)\n      } else {\n        resolve(data)\n      }\n    })\n  })\n}\nasync function route(url) {\n  let view = \"404.html\"\n  switch (url) {\n    case \"/\":\n      view = \'index.html\';\n      break;\n    default:\n      view = view;\n      break;\n  }\n  let html = await render(url);\n  return html;\n}\napp.use(async (ctx) => {\n  let url = ctx.request.url;\n  let html = await route(url);\n  ctx.body = html;\n})\napp.listen(1111);\n```\n### koa-router的使用\n- 访问127.0.0.1:1111\n- 访问127.0.0.1:1111/page/page1\n- 访问127.0.0.1:1111/page/page2\n```js\nconst Koa = require(\"koa\");\nconst fs = require(\"fs\");\nconst app = new Koa();\nconst Router = require(\"koa-router\");\n\n// 子路由1\nlet home = new Router();\nhome.get(\"/\", async (ctx) => {\n  ctx.body = \"<h1>hello Router</>\";\n})\n// 子路由2\nlet page = new Router();\npage.get(\"/page1\", async (ctx) => {\n  ctx.body = \"page1\"\n}).get(\"/page2\", async (ctx) => {\n  ctx.body = \"page2\"\n})\n// 装载路由\nlet router = new Router();\nrouter.use(\'/\', home.routes(), home.allowedMethods())\nrouter.use(\'/page\', page.routes(), page.allowedMethods())\n// 加载路由中间件\napp.use(router.routes()).use(router.allowedMethods())\napp.listen(1111)\n```\n### koa获取get请求参数\n- 访问127.0.0.1:1111/page/page1?id=1\n```js\nconst Koa = require(\"koa\");\nconst app = new Koa();\napp.use( async (ctx)=>{\n  let url = ctx.url;\n  let query = ctx.request.query;\n  let querystring = ctx.request.querystring;\n\n  let _query = ctx.query;\n  let _querystring = ctx.querystring;\n\n  ctx.body = {\n    url,\n    query,\n    querystring,\n    _query,\n    _querystring\n  }\n})\napp.listen(1111)\n```\n### 解析post请求上下文的表单数据\n- koa没有封装post请求参数\n```js\nfunction parsePostData(ctx) {\n  return new Promise((resolve, reject) => {\n    try {\n      let postdata = \"\";\n      ctx.req.addListener(\'data\', (data) => {\n        postdata += data\n      })\n      ctx.req.addListener(\'end\', () => {\n        let parseData = parseQuery(postdata);\n        resolve(parseData)\n      })\n    } catch (err) {\n      reject(err)\n    }\n  })\n}\n\nfunction parseQuery(queryStr) {\n  let queryData = {};\n  let queryStrList = queryStr.split(\"&\");\n  for (let [index, queryStr] of queryStrList.entries()) {\n    let itemList = queryStr.split(\"=\");\n    queryData[itemList[0]] = decodeURIComponent(itemList[1])\n  }\n  return queryData\n}\n\nconst Koa = require(\"koa\");\nconst app = new Koa();\n\napp.use(async (ctx) => {\n  if (ctx.method == \"GET\") {\n    let html = `\n      <h1>koa2 request post demo</h1>\n      <form method=\"POST\" action=\"/\">\n        <p>userName</p>\n        <input name=\"userName\" /><br/>\n        <p>nickName</p>\n        <input name=\"nickName\" /><br/>\n        <p>email</p>\n        <input name=\"email\" /><br/>\n        <button type=\"submit\">submit</button>\n      </form>`\n    ctx.body = html;\n  }else if(ctx.method==\'POST\'){\n    let postData = await parsePostData(ctx);\n    ctx.body = postData;\n  }\n})\napp.listen(1111)\n```\n### koa-bodyparse的使用\n- koa-bodyparse是解析POST和GET请求的\n```js\nconst Koa = require(\"koa\");\nconst app = new Koa();\nconst bodyParser = require(\"koa-bodyparser\");\n\napp.use(bodyParser());\n\napp.use(async (ctx) => {\n  if (ctx.method == \"GET\") {\n    let html = `\n      <form method=\"POST\" action=\"/\">\n        <p>userName</p>\n        <input name=\"userName\" /><br/>\n        <p>nickName</p>\n        <input name=\"nickName\" /><br/>\n        <p>email</p>\n        <input name=\"email\" /><br/>\n        <button type=\"submit\">submit</button>\n      </form>\n    `\n    ctx.body = html\n  } else if (ctx.method == \"POST\") {\n    let postData = ctx.request.body\n    ctx.body = postData;\n  }\n})\napp.listen(1111)\n```\n### koa实现静态服务器功能\n- 在入口文件中建一个static的文件夹，里面放有静态文件\n```js\nconst Koa = require(\'koa\');\nconst path = require(\"path\");\nconst fs = require(\"fs\");\nconst url = require(\"url\");\nconst app = new Koa();\n// 静态文件夹相对入口文件的位置\nconst staticPath = \"./static\";\n// 定义文件类型\nlet mimes = {\n  \'css\': \'text/css\',\n  \'less\': \'text/css\',\n  \'gif\': \'image/gif\',\n  \'html\': \'text/html\',\n  \'ico\': \'image/x-icon\',\n  \'jpeg\': \'image/jpeg\',\n  \'jpg\': \'image/jpeg\',\n  \'js\': \'text/javascript\',\n  \'json\': \'application/json\',\n  \'pdf\': \'application/pdf\',\n  \'png\': \'image/png\',\n  \'svg\': \'image/svg+xml\',\n  \'swf\': \'application/x-shockwave-flash\',\n  \'tiff\': \'image/tiff\',\n  \'txt\': \'text/plain\',\n  \'wav\': \'audio/x-wav\',\n  \'wma\': \'audio/x-ms-wma\',\n  \'wmv\': \'video/x-ms-wmv\',\n  \'xml\': \'text/xml\'\n}\n// 读取目录内容\nfunction walk(reqPath) {\n  let files = fs.readdirSync(reqPath);\n  let dirList = [];\n  let fileList = [];\n  for (let i = 0; i < files.length; i++) {\n    let item = files[i];\n    let itemArr = item.split(\"\\.\");\n    let itemMime = (itemArr.length > 1) ? itemArr[itemArr.length - 1] : \"undefined\";\n    if (typeof mimes[itemMime] === \"undefined\") {\n      dirList.push(files[i]);\n    } else {\n      fileList.push(files[i])\n    }\n  }\n  let result = dirList.concat(fileList);\n  return result;\n}\n// 封装目录内容\nfunction dir(url, reqPath) {\n  let contentList = walk(reqPath);\n  let html = \"\";\n  for (let [index, item] of contentList.entries()) {\n    html += `<li><a href=\"${url===\'/\'?\'\':url}/${item}\">${item}</a></li>`\n  }\n  return \"<ul>\" + html + \"<ul/>\"\n}\n// 读取文件方法\nfunction file(filePath) {\n  let content = fs.readFileSync(filePath, \'binary\');\n  return content;\n}\n// 获取静态文件内容\nasync function content(ctx, fullStaticPath) {\n  let reqPath = path.join(fullStaticPath, ctx.url);\n  let exist = fs.existsSync(reqPath);\n  let content = \"\";\n  if (!exist) {\n    content = \"404\";\n  } else {\n    let stat = fs.statSync(reqPath);\n    if (stat.isDirectory()) {\n      content = dir(ctx.url, reqPath);\n    } else {\n      content = await file(reqPath);\n    }\n  }\n  return content;\n}\n// 解析请求内容\nfunction parseMime(url) {\n  let extName = path.extname(url);\n  extName = extName ? extName.slice(1) : \"unknown\";\n  return mimes[extName]\n}\n// 使用中间件\napp.use(async (ctx) => {\n  let fullStaticPath = path.join(__dirname, staticPath);\n  let _content = await content(ctx, fullStaticPath);\n  let _mime = parseMime(ctx.url)\n  if (_mime) {\n    ctx.type = _mime;\n  }\n  if (_mime && _mime.indexOf(\"image/\") >= 0) {\n    ctx.res.writeHead(200)\n    ctx.res.write(_content, \'binary\')\n    ctx.res.end();\n  } else {\n    ctx.body = _content;\n  }\n})\napp.listen(1111);\n```\n### koa-static实现静态文件夹\n```js\nconst Koa = require(\"koa\");\nconst path = require(\"path\");\nconst static = require(\"koa-static\");\nconst app = new Koa();\n\nconst staticPath = \"./static\"\n\napp.use(static(\n  path.join(__dirname, staticPath)\n))\n\napp.use((ctx) => {\n  ctx.body = \"hello \"\n})\napp.listen(1111)\n```\n### 总结\n- koa相对比express来说，非常轻量，灵活度很大，开发者可以针对自己的项目使用合适的中间件，极大提高了工作效率，更重要的是async/await的使用，解决了回调嵌套的问题，代码看起来不冗余，处理异步操作更加舒服。\n- 该篇只是介绍了koa的用法和原理，koa源码的学习，放在了以后，毕竟后台管理系统的重点不是koa的源码。\n', '15', 'PUBLISHED', '', '2019-03-09 17:21:30', '0');
INSERT INTO `post` VALUES ('31', '服务器文件结构', '## 服务器文件结构\n+ app.js **入口**\n	+ api **Controller**\n		+ admin **用户的增删改查**\n			+ admin.controller.js\n			+ admin.js\n			+ category.controller.js\n			+ laboratory.controller.js\n			+ post.controller.js\n			+ tag.controller.js\n		+ oauth **github认证相关**\n			+ github.controller.js\n			+ index.js\n		+ post **发表文章相关**\n			+ comment.controller.js\n			+ post.controller.js\n			+ post.js\n		+ track **所在位置**\n			+ track.controller.js\n			+ track.js\n	+ config **配置参数**\n		+ koa.js\n		+ environment\n			+ development.js\n			+ index.js\n		+ src **静态文件夹**\n			+ tempUploads\n			+ uploads\n				+ 20190226\n					+ 1551191742895.png\n				+ 20190228\n					+ 1551361201136.png\n					+ 1551362238172.png\n	+ middlreware **中间件**\n		+ tokenError.js\n	+ routes **路由管理**\n		+ index.js\n	+ util **一些公共方法**\n        + admin-account.js \n        + draft-redis.js\n        + draft-socketio.js\n        + helper.js\n        + mysql-async.js\n        + redis-mysql.js\n        + redis-store.js\n### 服务器入口文件\n```js\n//app.js\nconst session = require(\'koa-session2\');\nconst http = require(\'http\');\nconst fs = require(\'fs\');\nconst path = require(\'path\');\n// 对koa的二次封装，涉及路由拦截，jwt认证等\nconst app = require(\'./config/koa\');\n// 基本配置参数\nconst config = require(\'./config/environment\');\n// mysql\nconst query = require(\'./util/mysql-async\');\n//redis\nconst Store = require(\'./util/redis-store\');\n//socket\nconst draftSocket = require(\'./util/draft-socketio\');\\\n//redis连接mysql\nconst redisMysql = require(\'./util/redis-mysql\');\n//redis初始化\napp.use(session({\n  store: new Store(config.db.redis),\n  ttl: 2 * 60 * 60 * 1000\n}));\n// 是否允许跨域\napp.use(async (ctx, next) => {\n  ctx.execSql = query;\n  ctx.set(\'Access-Control-Allow-Origin\', config.accessControlAllowOrigin);\n  await next();\n});\n// routes\nfs.readdirSync(path.join(__dirname, \'routes\')).forEach(function (file) {\n  if (~file.indexOf(\'.js\')) {\n    app.use(require(path.join(__dirname, \'routes\', file)).routes());\n  }\n});\n//开启服务器\nconst server = http.createServer(app.callback())\n  .listen(config.port)\n  .on(\'listening\', function () {\n    console.log(\'server listening on: \' + config.port);\n  });\n// 初始化websocket\ndraftSocket.initSocket(server);\n// 初始化定时任务\nredisMysql.redisToMysqlTask();\n```\n### 总结\n- 这是服务器的文件结构和入口文件，其中还有一些细节没有展示，比如如何连接redis，如何连接数据库，路由捕获，jwt认证，socket的前后端联调等，这些一一会在后面介绍。\n\n', '16', 'PUBLISHED', '', '2019-03-09 17:22:29', '0');
INSERT INTO `post` VALUES ('32', '使用koa-session进行路由拦截', '## 使用koa-session进行路由拦截\n\n### 路由拦截的意义\n\n>根据标识（session）来判断用户是否是合法用户，为了保证这个表示的安全性，这个标识可由服务端生成，并且客户端不能随意修改，每次客户端在请求接口前，必须要查询session的合法性。\n### session与路由拦截\n1. session:存储在cookie中的一种识别用户身份和行为的有效信息。\n2. 所谓拦截就是在用户指定行为前，进行session校验，判断是否是合法用户\n3. 常用的常用的拦截有三种：1.session 2.token 3.token+session\n### 使用koa-session设置session\n\n```js\nconst session = require(\'koa-session\');\nconst Koa = require(\'koa\');\nconst Router = require(\'koa-router\');\nconst app = new Koa();\n\napp.keys = [\'some secret hurr\'];\n\nconst CONFIG = {\n  key: \'koa:sess\', \n  maxAge: 86400000, //这个是确定cookie的有效期，默认是一天。\n  overwrite: true, \n  httpOnly: true, //表示是否可以通过javascript来修改，设成true会更加安全\n  signed: true, //cookie的安全性 会自动给cookie加上一个sha256的签名\n  rolling: false, //这两个都是涉及到cookie有效期的更新策\n  renew: false, // 这两个都是涉及到cookie有效期的更新策\n};\napp.use(session(CONFIG, app));\nlet home = new Router();\n// 每次在get请求前进行判断\nhome.get(\"/\",async (ctx)=>{\n  if (ctx.path === \'/favicon.ico\') return;\n  let n = ctx.session.views || 0;\n  ctx.session.views = ++n;\n  if(n==17){\n    throw new Error({\n      success:1\n    })\n  }else{\n    ctx.body ={\n      success:0\n    };\n  }\n})\nconst router = new Router();\nrouter.use(\"/\",home.routes())\napp.use(router.routes());\napp.listen(1111);\n```\n### 客户端获取session是否合法\n\n```js\naxios.interceptors.response.use(\n  response => {\n    return response;\n  },\n  error => {\n    if (error.response.success === 1) {\n        router.push(\'/login\');\n    }\n    return Promise.reject(error);\n  }\n)\n```\n\n### 总结\n- session这种是由服务端生成的，通过cookie传输，过期时间由服务器设定，每次 请求前都要检测session是否存在，存在跨域的问题', '15', 'PUBLISHED', '', '2019-03-09 17:22:52', '0');
INSERT INTO `post` VALUES ('33', '使用 jwt 实现用户认证', '## 使用 jwt 实现用户认证\n\n### [源代码地址](https://github.com/dirkhe1051931999/common-demo)\n\n### jwt 介绍\n\n1. 什么是 jwt：jwt 全称是 jsonwebtoken，本质上是一个 token（秘钥），就像去电影院看电影，你得拿一张票，这张票有时间限制，区域限制，使用人数限制，token 就像一个电影票，必须满足合适的时间、区域、人数，才能“通过”。\n2. jwt 依赖的库：kow-jwt（jsonwebtoken 的中间件），jsonwebtoken(用户生成 token )\n3. jwt 的 token 可以存在客户端的或者服务端\n\n### 应用场景\n\n1. 当请求接口时，需要先要判断用户是否合法，不合法 throw 异常（401）\n2. 指定接口不需要权限（比如静态文件），需要过滤指定接口\n\n### 使用条件\n\n1. 服务端 token 检验与生成，客户端 token 存储\n\n- 使用 jsonwebtoken 生成 token\n- 使用 koa-kwt 加密 token，可设置过滤某些接口\n\n2. 客户端请求接口前，需要在 request 设置 Authorization:Bearer [token]字段\n\n- axios.interceptors.request 设置 Authorization:Bearer [token]字段\n\n3. 接口代理\n\n- 如果是 127.0.0.1 的 8080 端口访问服务端接口，就涉及代理的问题，需要在 webpack 文件夹中的 config 文件设置代理\n\n4. 客户端接口对 401 状态拦截，跳转指定页面，比如登录页\n\n- axios.interceptors.response 对状态进行捕获\n\n5. 客户端路由拦截，无效 token（退出登录后）无法再次访问要认证的接口\n\n- 使用 beforeEach 钩子进行路由拦截，拦截前需要在客户端路由 meta 中设置是否需要拦截\n\n6. 客户端设置 token\n\n- 定义几个 vue 页面的作用\n  - getData.vue 请求被过滤的接口\n  - getUserInfo.vue 只有有权限才能进入这个页面\n  - login.vue 登录页面\n  - logout.vue 退出登录页面\n\n### 具体实现\n\n#### 服务端实现\n\n> server/jw.js\n\n- 具体步骤\n\n1. token 判断\n\n```js\nasync function tokenError(ctx, next) {\n  try {\n    const token = ctx.header.authorization\n    if (token) {\n      try {\n        let payload = await verify(token.split(\' \')[1], \'key1\')\n        ctx.user = {\n          name: payload.name,\n          id: payload.id\n        }\n      } catch (error) {\n        console.log(\'token verify fail: \', error)\n      }\n    }\n    await next()\n  } catch (error) {\n    if (error.status === 401) {\n      ctx.status = 401\n      ctx.body = {\n        success: 1,\n        message: \'认证失败\'\n      }\n    } else {\n      ctx.status = 404\n      ctx.body = {\n        success: 1,\n        message: \'语法错误或路径错误\'\n      }\n    }\n  }\n}\n```\n\n2. 服务端设置接口\n\n```js\nrouter.get(\'/login\', async ctx => {\n  const userToken = {\n    name: \'Jen\',\n    id: \'01\'\n  }\n  const token = jwt.sign(userToken, \'key1\', {\n    expiresIn: \'2h\'\n  })\n  ctx.body = {\n    success: 0,\n    token: token,\n    message: \'登录成功\'\n  }\n})\nrouter.get(\'/logout\', async ctx => {\n  ctx.body = {\n    success: 0,\n    message: \'退出成功\'\n  }\n})\nrouter.get(\'/getdata\', async ctx => {\n  ctx.body = {\n    success: 0,\n    message: \'getdata的get方式为忽略token判断的路由\'\n  }\n})\nrouter.get(\'/userInfo\', async ctx => {\n  let token = ctx.header.authorization\n  ctx.body = {\n    success: 0,\n    message: token\n  }\n})\n```\n\n3. 装载拦截和进行加密过滤\n\n```js\napp.use(tokenError)\napp.use(\n  koaJwt({\n    secret: \'key1\'\n  }).unless({\n    path: [/\\/getdata/, /\\/logout/, /\\/login/]\n  })\n)\n```\n\n#### 添加 Authorization 和接口设置\n\n> src/http2/http.js\n\n- 具体步骤\n\n1. Authorization\n\n```js\naxios.defaults.headers.post[\'Content-Type\'] = \'application/x-www-form-urlencoded\'\naxios.defaults.timeout = 20000\n// 手动设置Authorization头\naxios.interceptors.request.use(\n  config => {\n    const token = localStorage.getItem(\'HAS_SET_TOKEN\')\n    if (token) {\n      // Bearer是JWT的认证头部信息\n      config.headers.common[\'Authorization\'] = \'Bearer \' + token\n    }\n    return config\n  },\n  error => {\n    return Promise.reject(error)\n  }\n)\n// 添加一个注射器\naxios.interceptors.response.use(\n  response => {\n    return response\n  },\n  error => {\n    return Promise.reject(error)\n  }\n)\n```\n\n2. 定义接口\n\n```js\n// 这是登录接口\nconst loginApi = \'/api/login\'\n// 这是获取用户信息接口\nconst getUserInfoApi = \'/api/userInfo\'\n// 这是过滤后的接口\nconst getDataApi = \'/api/getdata\'\n// 这是首页\nconst loginOutApi = \'/api/logout\'\n```\n\n#### 接口代理\n\n> config/index.js\n\n```js\nmodule.exports = {\n  dev: {\n    \'/api\': {\n      target: \'http://127.0.0.1:1111\',\n      changeOrange: true,\n      pathRewrite: {\n        \'^/api\': \'\'\n      }\n    }\n  }\n}\n```\n\n#### 状态拦截\n\n> main.js\n\n```js\naxios.interceptors.response.use(\n  response => {\n    return response\n  },\n  error => {\n    if (error.response.status === 401) {\n      router.push(\'/login\')\n    } else {\n    }\n    return Promise.catch(error)\n  }\n)\n```\n\n#### 客户端路由拦截\n\n> src/router/index.js\n\n- 具体步骤\n\n1. 路由设置\n\n```js\nroutes: [\n  {\n    path: \'/login\',\n    name: \'Login\',\n    component: Login\n  },\n  {\n    path: \'/logout\',\n    name: \'logout\',\n    component: Logout,\n    meta: {\n      requireAuth: true\n    }\n  },\n  {\n    path: \'/userInfo\',\n    name: \'GetUserInfo\',\n    component: GetUserInfo,\n    meta: {\n      requireAuth: true\n    }\n  },\n  {\n    path: \'/getdata\',\n    name: \'GetData\',\n    component: GetData,\n    meta: {\n      requireAuth: false\n    }\n  }\n]\n```\n\n> 可以看出/login 是登录页面，所以不需要判断是否需要重定向，getdata 是过滤的接口，所以也不用判断是否需要重定向\n\n2. 路由拦截\n\n```js\n// to即将要进入的路由\n// from导航要离开的路由\n// next next()是进行管道中的下一个钩子，如果全部钩子执行完了，则导航的状态就是 confirmed ；next(\"/login\")路由跳转\nrouter.beforeEach((to, from, next) => {\n  if (to.meta.requireAuth) {\n    const token = localStorage.getItem(\'HAS_SET_TOKEN\')\n    if (token && token !== \'null\') {\n      next()\n    } else {\n      next(\'/login\')\n    }\n  } else {\n    next()\n  }\n})\n```\n\n#### 客户端设置 token\n\n- 设置 token\n\n> src/components/login.vue\n\n```js\nhttp.login().then(res => {\n  if (res.success == 0) {\n    this.msg = \'登录成功\'\n    localStorage.setItem(\'HAS_SET_TOKEN\', res.token)\n  }\n})\n```\n\n- 删除 token\n\n> src/components/logout.vue\n\n```js\nif (res.success == 0) {\n  this.msg = res.message\n  localStorage.removeItem(\'HAS_SET_TOKEN\')\n}\n```\n\n### 总结\n\n1. 既然 token 是存在 localStorage 中，那为什么不直接存一个 localStorage 进行用户校验，问题的关键点是，这个 localStorage 的 value 是由服务端分配的，秘钥的校验和生成都在服务端完成，localStorage 存储是为了解决 session 的跨域问题，当然 jwt 产生的 token 也可以存在服务端\n2. jwt 可以实现单点登录，但是无法控制单点登录，比如一个账户在 A 设备登录后也能在 B 设备登录，两者不冲突\n3. jwt 因为是存在 request 的 Authorization 字段中，那非法用户就可以先获取到这个值，然后模拟登录，存在安全问题\n4. jwt 解决了跨域的问题，session+cookie 存在跨域问题，比如一个项目是分布式部署（a.com,b.com） 需要做多机共享 session 机制，并且 cookie 也存在安全问题\n5. jwt 生成的 token 是无法手动删除的，只能等在过期或者改动秘钥（就是那个 key1）才能失效，要在客户端进行两个操作：1、每次登录前判断 localStorage 是否存在，如果存在就证明了已经设置了 Authorization 了；2、退出登录，删除 localStorage，localStorage 不存在了，所以前端路由会 next(\'/login\')，只会跳转到登录页面\n', '15', 'PUBLISHED', '', '2019-03-09 17:23:17', '0');
INSERT INTO `post` VALUES ('34', 'node+koa 如何连接数据库', '## node+koa 如何连接数据库\n\n```js\nconst Koa = require(\'koa\');\nconst app = new Koa();\nconst mysql = require(\'mysql\');\n// mysql配置相关\nconst config = {\n  host: \'127.0.0.1\',\n  user: \'root\',\n  password: \'123\',\n  database: \'my_vue_blog\',\n  connectionLimit: 10\n};\n// 创建连接池\nconst pool = mysql.createPool({\n  host: config.host,\n  user: config.user,\n  password: config.password,\n  database: config.database,\n  connectionLimit: config.connectionLimit\n});\n// 执行query语句\nlet query = (sql, values) => {\n  return new Promise((resolve, reject) => {\n    pool.getConnection((err, connection) => {\n      if (err) {\n        reject(err);\n      } else {\n        connection.query(sql, values, (err, rows) => {\n          connection.release();\n          if (err) {\n            return reject(err);\n          } else {\n            return resolve(rows);\n          }\n        });\n      }\n    });\n  });\n};\n// 装载中间件，挂在上下文的execSql上\napp.use(async (ctx, next) => {\n  ctx.execSql = query;\n  await next();\n});\n// 执行sql语句\napp.use(async (ctx) => {\n  let result = await ctx.execSql(`show databases`);\n  ctx.body = {\n    result\n  };\n});\napp.listen(1111);\n```\n\n### 说点其他\n\n- node 连接 mysql 或者 mongoDB 等数据库不太难，所以这章就简单一笔带过。\n- 一般来说为了加速开发，mysql 的使用都在可视化的操作工具中，我一般用 navicat，这是 navicat for mysql 的破解补丁，链接: https://pan.baidu.com/s/135XW17a-5nmLZU9tpiqFRQ 提取码: h9ij\n', '14', 'PUBLISHED', '', '2019-03-09 17:24:36', '0');
INSERT INTO `post` VALUES ('35', 'node+koa 如何连接 redis', '## node+koa 如何连接 redis\n\n> redis 是一个高性能 key-value 数据库，但还支持多种数据结构的存储，比如 hash，set，list 等。redis 是一个内存数据库，常用用来做计数器，队列。mysql 可以理解是磁盘数据库，每张表对应的数据库目录下有 table_name.frm 文件，存储的是表定义信息，有 64kb 的限制，但是 mysql 有些临时表超过限制后也会存在内存中。redis 相对比 mysql 而且更喜欢处理“热数据”，即需要快速查询或插入的数据。因为直接吃的是内存，所以跟磁盘相比，性能和成本需要考虑。\n\n### koa 如何连接 redis\n\n```js\nconst Koa = require(\'koa\');\nconst Redis = require(\'ioredis\');\nconst app = new Koa();\nconst session = require(\'koa-session2\');\nconst { Store } = require(\'koa-session2\');\n// 配置文件\nvar config = {\n  port: 6379,\n  host: \'127.0.0.1\',\n  db: 3,\n  options: {\n    return_buffers: false,\n    auth_pass: \'\'\n  }\n};\n// redis与session\nclass RedisStore extends Store {\n  constructor(redisConfig) {\n    super();\n    this.redis = new Redis(redisConfig);\n  }\n  async get(sid, ctx) {\n    let data = await this.redis.get(`SESSION:${sid}`);\n    return JSON.parse(data);\n  }\n  async set(session, { sid = this.getID(24), maxAge = 1000000 } = {}, ctx) {\n    try {\n      await this.redis.set(`SESSION:${sid}`, JSON.stringify(session), \'EX\', maxAge / 1000);\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n  async destroy(sid, ctx) {\n    return await this.redis.del(`SESSION:${sid}`);\n  }\n}\n// redis的增删改查\nclass DraftRedis {\n  constructor(redisConfig) {\n    this.redis = new Redis(redisConfig);\n  }\n  async get(key) {\n    let data = await this.redis.get(key);\n    return JSON.parse(data);\n  }\n  async set(key, data, maxAge = 7 * 24 * 60 * 60 * 1000) {\n    try {\n      // Use redis set EX to automatically drop expired sessions\n      await this.redis.set(key, JSON.stringify(data), \'EX\', maxAge / 1000);\n    } catch (e) {}\n    return \'success\';\n  }\n\n  async destroy(key) {\n    return await this.redis.del(key);\n  }\n}\n// 设置rediskey的生成时间\napp.use(\n  session({\n    store: new RedisStore(config),\n    ttl: 2 * 60 * 60 * 1000\n  })\n);\n// redis的基本使用\napp.use(async (ctx) => {\n  let draftRedis = new DraftRedis(config);\n  await draftRedis.set(\'DRAFTPSOTKEY\', \'hello world\');\n  let redisPost = await draftRedis.get(\'DRAFTPSOTKEY\');\n  if (redisPost) {\n    console.log(redisPost);\n  }\n  ctx.body = \'连接redis\';\n});\n\napp.listen(1111, () => {\n  console.log(\'listen\', 1111);\n});\n```\n\n- 在使用 redis 前，要确保自己开开启服务\n- koa-session2 的使用是为了设置 redis key 的 TTL\n- redis 我是用可视化工具 RedisDesktopManager 操作的\n\n### mysql 和 redis 同时使用\n\n```js\nconst Koa = require(\'koa\');\nconst Redis = require(\'ioredis\');\nconst mysql = require(\'mysql\');\nconst app = new Koa();\nconst session = require(\'koa-session2\');\nconst { Store } = require(\'koa-session2\');\n// 配置文件\nvar config = {\n  port: 6379,\n  host: \'127.0.0.1\',\n  db: 3,\n  options: {\n    return_buffers: false,\n    auth_pass: \'\'\n  }\n};\nconst mysql_config = {\n  host: \'127.0.0.1\',\n  user: \'root\',\n  password: \'123\',\n  database: \'my_vue_blog\',\n  connectionLimit: 10\n};\n// 连接池\nconst pool = mysql.createPool({\n  host: mysql_config.host,\n  user: mysql_config.user,\n  password: mysql_config.password,\n  database: mysql_config.database,\n  connectionLimit: mysql_config.connectionLimit\n});\n// 连接mysql\nlet query = (sql, values) => {\n  return new Promise((resolve, reject) => {\n    pool.getConnection((err, connection) => {\n      if (err) {\n        reject(err);\n      } else {\n        connection.query(sql, values, (err, rows) => {\n          connection.release();\n          if (err) {\n            return reject(err);\n          } else {\n            return resolve(rows);\n          }\n        });\n      }\n    });\n  });\n};\n// redis与session\nclass RedisStore extends Store {\n  constructor(redisConfig) {\n    super();\n    this.redis = new Redis(redisConfig);\n  }\n  async get(sid, ctx) {\n    let data = await this.redis.get(`SESSION:${sid}`);\n    return JSON.parse(data);\n  }\n  async set(session, { sid = this.getID(24), maxAge = 1000000 } = {}, ctx) {\n    try {\n      await this.redis.set(`SESSION:${sid}`, JSON.stringify(session), \'EX\', maxAge / 1000);\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n  async destroy(sid, ctx) {\n    return await this.redis.del(`SESSION:${sid}`);\n  }\n}\n// redis的增删改查\nclass DraftRedis {\n  constructor(redisConfig) {\n    this.redis = new Redis(redisConfig);\n  }\n  async get(key) {\n    let data = await this.redis.get(key);\n    return JSON.parse(data);\n  }\n  async set(key, data, maxAge = 7 * 24 * 60 * 60 * 1000) {\n    try {\n      // Use redis set EX to automatically drop expired sessions\n      await this.redis.set(key, JSON.stringify(data), \'EX\', maxAge / 1000);\n    } catch (e) {}\n    return \'success\';\n  }\n\n  async destroy(key) {\n    return await this.redis.del(key);\n  }\n}\n// 设置rediskey的生成时间\napp.use(\n  session({\n    store: new RedisStore(config),\n    ttl: 2 * 60 * 60 * 1000\n  })\n);\n// 装载mysql\napp.use(async (ctx, next) => {\n  ctx.execSql = query;\n  await next();\n});\n// redis的基本使用\napp.use(async (ctx) => {\n  let draftRedis = new DraftRedis(config);\n  let result = await ctx.execSql(`show databases`);\n  await draftRedis.set(\'DRAFTPSOTKEY\', result);\n  let redisPost = await draftRedis.get(\'DRAFTPSOTKEY\');\n  if (redisPost) {\n    ctx.body = redisPost;\n  }\n});\n\napp.listen(1111, () => {\n  console.log(\'listen\', 1111);\n});\n```\n\n- 当然也可以使用定时脚本，每天定时往数据库写入数据，node-schedule 这个插件就可以写定时脚本，比如\n\n```js\nconst schedule = require(\'node-schedule\');\nlet rule = new schedule.RecurrenceRule();\nrule.hour = 3;\nrule.minute = 0;\nschedule.scheduleJob(rule, async () => {\n  // do somethings\n});\n```\n\n- 为什么要定时向 mysql 写入数据呢，举个例子，常见的点赞，取消点赞的高频次操作，每次都要读写数据库，大量的操作肯定会影响数据库的性能，所以就需要做缓存，缓存就是先放在 redis 中，比如每天晚上 12 点缓存一次，把点赞的数据存入 mysql 中，12 点前的点赞与点赞数据查询都在 redis 中完成。\n', '15', 'PUBLISHED', '', '2019-03-09 17:25:02', '0');
INSERT INTO `post` VALUES ('36', 'node+koa+vue+soket 的使用', '## node+koa+vue+soket 的使用\n\n> socket 是一种双向通信协议，可以实现当第一个 HTTP 请求建立 TCP 连接后，之后的请求都不用再发 HTTP 请求了，socket 分为服务端和客户端，双方都可主动互发或接收数据。\n\n### socket 服务端的使用\n\n```js\nconst Koa = require(\'koa\');\nconst http = require(\'http\');\nconst app = new Koa();\nconst SocketIO = require(\'socket.io\');\nconst socketioPath = \'/testsocketiopath\';\n\nlet initSocket = (server) => {\n  console.log(\'init websocket\');\n  let socketHandle = SocketIO(server, {\n    serveClient: true,\n    path: socketioPath\n  });\n  socketHandle.on(\'connection\', (socket) => {\n    console.log(\'socket connected\');\n    console.log(socket.id);\n    socket.on(\'disconnect\', () => {\n      console.log(\'我正在执行服务端的disconnect，我的id是\', socket.id);\n    });\n    socket.on(\'save\', async (data) => {\n      console.log(\'我正在执行服务端的save，我正在保存的数据是\', data);\n      socket.emit(\'save\', \'save\');\n    });\n    socket.on(\'get\', async () => {\n      let data = \'我是服务端获取到的数据\';\n      console.log(\'我正在执行服务端的get，我获取到的数据是\', data);\n      socket.emit(\'get\', data);\n    });\n    socket.on(\'clear\', async () => {\n      console.log(\'我正在执行服务端的clear，点击按钮了，我要情况数据了\');\n      socket.emit(\'clear\', true);\n    });\n  });\n};\napp.use(async (ctx) => {\n  ctx.body = \'websoket\';\n});\nconst server = http\n  .createServer(app.callback())\n  .listen(1111)\n  .on(\'listening\', () => {\n    console.log(\'listen\', 1111);\n  });\ninitSocket(server);\n```\n\n- `save`是保存数据的协议，接收客户端发过来的数据，可以实时保存记录的文章，先存在 redis 中，然后一段时间存在数据库中；`get`是获取数据，在获取数据后，可以发向客户端；`clear`是清除数据，可以清空 redis 的数据和 mysql 的数据。\n- 使用 socket 进行通信的时候，记着要加一个通道，就是`/testsocketiopath`\n\n### socket 客户端的使用\n\n> 客户端是 vue 开发的，依赖两个包`\"vue-router\": \"^3.0.1\"`, `\"vue-socket.io\": \"^2.1.1-a\"`，注意版本。\n\n```html\n<template>\n  <div class=\"\">\n    <p>从websoket服务端拿来的数据是：{{serverData}}</p>\n    <p>{{input}}</p>\n    <input type=\"text\" v-model=\"input\" />\n    <button @click=\"submit\">submit</button>\n  </div>\n</template>\n```\n\n```js\nexport default {\n  name: \'Websocket\',\n  data() {\n    return {\n      input: \'\',\n      serverData: \'\'\n    };\n  },\n  methods: {\n    submit() {\n      this.input = \'\';\n      this.$socket.emit(\'clear\');\n    },\n    getData() {\n      this.$socket.emit(\'get\');\n    }\n  },\n  watch: {\n    input(val) {\n      this.$socket.emit(\'save\', val);\n    }\n  },\n  sockets: {\n    connect: function() {\n      console.log(\'socket connected\');\n    },\n    get(val) {\n      this.serverData = val;\n    }\n  },\n  created() {\n    this.getData();\n  },\n  mounted() {}\n};\n```\n', '17', 'PUBLISHED', '', '2019-03-09 17:25:57', '0');
INSERT INTO `post` VALUES ('37', 'Vue Router 的导航守卫', '## Vue Router 的导航守卫\n\n> [使用 jwt 实现用户认证](https://github.com/dirkhe1051931999/hjBlog/blob/master/blog-management/lessons/05.md)这篇博客中有用到 导航守卫，今天就来总结总结\n> vue-rotuer 通过导航守卫来监听路由变化，其中导航守卫分为 3 类：全局，单个路由和组件路由\n\n### 使用场景\n\n- 需要在进入路由前进行一定操作，比如没权限时跳转 login 页面\n- 需要组件里路由更新时（动态路由的更新）进行一定操作，比如 \"/test/01\" => \"/test/02\"\n- 需要在单个路由进入前做一样操作，比如在单页中，路由进入前使用某种与客户端定制的协议\n\n### 路由\n\n```js\nconst router = new Router({\n  routes: [\n    {\n      path: \'/\',\n      redirect: \'/demo1\'\n    },\n    {\n      path: \'/demo1/:id\',\n      component: Demo1,\n      beforeEnter: (to, from, next) => {\n        next()\n      }\n    },\n    {\n      path: \'/demo2\',\n      component: Demo2\n    },\n    {\n      path: \'/demo3\',\n      component: Demo3\n    }\n  ]\n})\n```\n\n### 具体分类\n\n1. 全局前置路由\n\n- to 即将要进入的路由\n- from 要进入的路由的上一个路由\n- next 需要用 next 方法，将 beforeEach 这个钩子 resolve，否则无法进入到下一个钩子\n  - next(false) 中断当前路由的跳转，路由会重置到 from 路由对应的位置\n  - next(\"/\") 跳转到指定地址，因为\"/\"会 redirect 到\"/demo1\"，\"/demo1\"的全局前置路由又 next(\"/\") 所以就会栈溢出\n  - next() 执行下一个钩子\n  - next(error) 抛出一个异常\n\n```js\nrouter.beforeEach((to, from, next) => {\n  next()\n})\n```\n\n2. 全局后置路由\n\n- to 和 from 和全局前置路由一致\n\n```js\nrouter.afterEach((to, from) => {})\n```\n\n3. 路由独享守卫\n\n- 参数和全局前置路由一致，也需要执行 next 方法\n\n```js\nrouter.beforeEnter((to, from, next) => {\n  next()\n})\n```\n\n> 前三个的执行顺序是 beforeEach=>beforeEnter=>afterEach\n\n4. 组件路由\n\n```js\n  beforeRouteEnter (to, from, next) {\n    next(vm=>{\n      console.log(vm,\'enter\')\n    })\n    // 在渲染该组件的对应路由被 confirm 前调用\n    // 不！能！获取组件实例 `this`\n    // 因为当守卫执行前，组件实例还没被创建\n  },\n  beforeRouteUpdate (to, from, next) {\n    console.log(this,\'update\')\n    next()\n    // 在当前路由改变，但是该组件被复用时调用\n    // 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候，\n    // 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。\n    // 可以访问组件实例 `this`\n  },\n  beforeRouteLeave (to, from, next) {\n    console.log(this,\'leave\')\n    next()\n    // 导航离开该组件的对应路由时调用\n    // 可以访问组件实例 `this`\n  }\n```\n\n> 第四个的执行顺序是 beforeRouteUpdate=>beforeRouteLeave=>beforeRouteEnter\n', '17', 'PUBLISHED', '', '2019-03-09 17:26:25', '0');
INSERT INTO `post` VALUES ('38', 'vue2.4 浅析', '## vue2.4 浅析\n\n### [源代码地址](https://github.com/dirkhe1051931999/common-demo)\n\n> vue 马上就要出 3.0 版本了，目前比较稳定是的 2.4 版本，在 2.4 版本中，又有哪些好玩的有趣的新特性呢，今天就来总结总结\n\n### 异步组件\n\n> 众所周知，vue 在使用单页时，会生成一个 app.js，app.js 就是打包的各项依赖的集合，我们常用 import 引入包或者组件，每次 import 后，都会把打包的代码放入 app.js 中，有时候我们希望在进入另一个路由的时候，再加载某个组件，达到异步的效果。2.4 之前是能通过[路由懒加载](https://router.vuejs.org/zh/guide/advanced/lazy-loading.html)或者 [keep-alive](https://cn.vuejs.org/v2/guide/components-dynamic-async.html) 提升性能，2.4 版本中提出了异步组件的概念：按需加载组件，达到提升性能的目的。<br>\n> 使用条件：vue 版本大于 2.4 vue-router 大于 2.4\n\n1. 路由的异步导入\n\n```js\n// router/index.js\n// import Demo1 from \"../components/demo1.vue\"\n// import Demo2 from \"../components/demo1.vue\"\nroutes: [\n  {\n    path: \'/\',\n    redirect: \'/demo1\'\n  },\n  {\n    path: \'/demo1\',\n    component: () => import(\'../components/demo1.vue\')\n    // component: Demo1\n  },\n  {\n    path: \'/demo2\',\n    component: () => import(\'../components/demo2.vue\')\n    // component: Demo2\n  }\n]\n```\n\n- 这里面需要注意：只要 import 组件后，就会打包放入 app.js 中\n\n- 使用异步导入：先进入/demo1，demo2.vue 是没有加载的\n  ![](https://github.com/dirkhe1051931999/hjBlog/tree/master/blog-vue/screenshot/01.png)\n- 使用 import 导入组件：先进入/demo1，demo2.vue 加载了\n  ![](https://github.com/dirkhe1051931999/hjBlog/tree/master/blog-vue/screenshot/02.png)\n\n2. 组件异步导入\n\n```html\n<!-- demo01.vue -->\n<div class=\"\">\n  这就是1\n  <!-- 我就是注释，这次我不删除 -->\n  <Child></Child>\n</div>\n```\n\n```js\nChild: () => import(\'./demo3.vue\')\n```\n\n```html\n<!-- demo02.vue -->\n<div class=\"\">\n  这就是2\n</div>\n```\n\n- 先进入/demo2 先加载 demo2 组件，进入/demo1 后才去加载 demo1.vue 和 demo2.vue 组件\n  [](https://github.com/dirkhe1051931999/hjBlog/tree/master/blog-vue/screenshot/03.jpg)\n  [](https://github.com/dirkhe1051931999/hjBlog/tree/master/blog-vue/screenshot/04.jpg)\n- 使用 import 导入组件，一次性 demo1.vue demo2.vue demo3.vue 同时加载\n\n### 父子组件数据传递( inheritAttrs + \\$attrs)\n\n> 众所周知，如果父组件想传给孙组件值（父-子-孙）就得父=>子 子->孙，可不可以父直接到孙？2.4 支持了\n\n```html\n<!-- 父：demo2.vue -->\n<Child :propa=\"propa\" :propb=\"propb\"></Child>\n```\n\n```js\n// 父：demo2.vue\nexport default {\n  props: [\'propa\']\n}\n```\n\n- 子没有注册 propb，渲染结果\n\n```html\n<!-- 子：demo3.vue -->\n<div propb=\"propb\">propa</div>\n```\n\n- 设置 inheritAttrs:false 不会把未被注册的 propb 呈现为普通的 HTML 属性 并且子可以通过**\\$attrs**获取到未注册的 propb，传递给孙\n\n```html\n<!-- 子：demo3.vue -->\n<InnerChild :propb=\"$attrs.propb\"></InnerChild>\n```\n\n```html\n<!-- 孙：demo4.vue -->\n<div>\n  inner-child的propb:{{propb}}\n</div>\n```\n\n> 这样子组件可以不用注册 propb，孙组件依然能获取到 propb\n\n### 父子组件通信\\$listeners\n\n> $listeners官方解释：包含了父作用域中的 (不含 .native 修饰器的) v-on 事件监听器。它可以通过 v-on=\"$listeners\" 传入内部组件——在创建更高层次的组件时非常有用。通俗理解就是子组件可以触发父组件的事件。\n\n- demo1.vue\n\n```html\n<div class=\"\">\n  这就是1\n  <Child :name=\"name\" :sex=\"sex\" @click=\"onTest\"></Child>\n</div>\n```\n\n```js\nexport default {\n  components: {\n    Child: () => import(\'./demo3.vue\')\n  },\n  data() {\n    return {\n      name: \'child\',\n      sex: \'man\'\n    }\n  },\n  computed: {},\n  watch: {},\n  methods: {\n    onTest() {\n      console.log(\'父级组件的点击事件\')\n    }\n  },\n  created() {},\n  mounted() {}\n}\n```\n\n- demo2.vue\n\n```html\n<div class=\"\">\n  <div class=\"\">\n    这就是2\n  </div>\n</div>\n```\n\n```js\nexport default {\n  components: {},\n  data() {\n    return {}\n  },\n  computed: {},\n  watch: {},\n  methods: {},\n  created() {},\n  mounted() {}\n}\n```\n\n- demo3.vue\n\n```html\n<div class=\"\">\n  child的name:{{name}}\n  <InnerChild :sex=\"$attrs.sex\" @click=\"onTest\" v-on=\"$listeners\"></InnerChild>\n</div>\n```\n\n```js\nexport default {\n  inheritAttrs: false,\n  props: {\n    name: String\n  },\n  components: {\n    InnerChild: () => import(\'./demo4.vue\')\n  },\n  data() {\n    return {}\n  },\n  computed: {},\n  watch: {},\n  methods: {\n    onTest() {\n      console.log(\'子级组件的点击事件\')\n    }\n  },\n  created() {},\n  mounted() {}\n}\n```\n\n- demo4.vue\n\n```html\n<div class=\"\">\n  inner-child的Sex:{{sex}}\n  <div @click=\"test\">button</div>\n</div>\n```\n\n```js\nexport default {\n  props: {\n    sex: String\n  },\n  data() {\n    return {}\n  },\n  computed: {},\n  watch: {},\n  methods: {\n    test() {\n      console.log(\'孙级组件派发点击事件\')\n      this.$emit(\'click\')\n    }\n  },\n  created() {},\n  mounted() {}\n}\n```\n\n> 可以看出，只要在孙组件注册了“click”事件，点击派发一次，那么子组件，父组件都会响应，因为子父都监听了“click”事件，如果取消了 v-on=\"\\$listeners\"，那么子组件可以监听“click”，但是父组件就监听不了了。\n\n### 总结\n\n- vue2.4 的这三种特性，准确的说这两种特性，二三其实是一种，对我们的开发是很有帮助的。\n', '17', 'PUBLISHED', '', '2019-03-09 17:26:42', '0');
INSERT INTO `post` VALUES ('39', 'nodejs 模块之 util 模块', '## nodejs 模块之 util 模块\n\n> util 模块是一些工具函数，来补充 nodejs 的 API，常见模块有如下\n\n- 把 async 或者返回 promise 的转成回调函数异步类型\n\n```js\nasync function fn() {\n  return \'hello fn\'\n}\nconst callbackFn = util.callbackify(fn)\n\ncallbackFn((err, ret) => {\n  console.log(ret)\n})\n\nfunction fn2() {\n  return Promise.resolve(\'hello fn2\')\n}\nconst callbackFn2 = util.callbackify(fn2)\ncallbackFn2((err, ret) => {\n  console.log(ret)\n})\n```\n\n- 把回调函数转成 promise 形式\n\n```js\n// 回调函数形式的读取文件\nconst fs = require(\'fs\')\nfs.readFile(\'./demo01.js\', (err, data) => {\n  if (err) {\n    return\n  }\n  console.log(data.toString())\n})\n\nconst util = require(\'util\')\n// 转成promise\nconst readFilePromise = util.promisify(fs.readFile)\nreadFilePromise(\'./demo01.js\').then(\n  data => {\n    console.log(data.toString())\n  },\n  err => {\n    console.log(err)\n  }\n)\n```\n\n- 占位符替换\n\n```js\nconst util = require(\'util\')\nconst format = util.format(\'%s,%s\', \'hello\', \'world\')\nconsole.log(format)\n```\n\n- 对对象进行格式化操作，并提供个性化方法\n\n```js\nconst util = require(\'util\')\nconst object = {\n  key1: [\'v1\', \'v2\', [\'v3\']],\n  key2: \'v4\',\n  key3: new Array(1, 2, 3)\n}\n// compact:是否独占一行\n// depth:显示层级 默认是2\n// breakLength ：超出多行换行\n\nconsole.log(util.inspect(object, { compact: true, depth: 2, breakLength: 20 }))\n```\n\n- 提供一些类型的判断\n\n```js\n// util一些类型的判断\nconst util = require(\'util\')\n// 是否是正则\nlet a = util.isRegExp(/some regexp/)\n// 是否是日期\nlet b = util.isDate(new Date())\n// 是否是error\nlet c = util.isError(new Error())\n// 是否是数组\nlet d = util.isArray([])\nconsole.log(a, b, c, d)\n```\n\n### 总结\n\n- util 常用的一个模块我觉得应该是将回调函数转成 promise 形式，因为 nodejs 有好多 API 都是异步回调形式，转成 promise 比较方便。\n', '14', 'PUBLISHED', '', '2019-03-09 17:27:08', '0');
INSERT INTO `post` VALUES ('40', 'axios 的拦截器', '## axios 的拦截器\n\n> [使用 jwt 实现用户认证](https://github.com/dirkhe1051931999/hjBlog/blob/master/blog-management/lessons/05.md)这篇博客中有用到 axios 的拦截器，今天就来总结总结\n> axios 是基于 Promise 的 http 库，可以用在浏览器和 node 中\n\n### axios 特点\n\n- 从浏览器中创建 XMLHttpRequests\n- 从 node.js 创建 http 请求\n- 支持 Promise API\n- 拦截请求和响应\n- 客户端支持防御 XSRF\n\n### 自定义 axios\n```js\n// myAxios.js\nvar customAxios = axios.create({\n  baseURL: \'https://cnodejs.org/api/v1\',\n  url: \'topics?page=1&tab=ask&limit=10&mdrender=true\',\n  method: \'get\',\n  timeout: 3000,\n  params: {\n    ID: 12345\n  },\n  headers: { Authorization: \'AUTH_TOKEN\' }\n})\n```\n\n> 自定义的参数可参考[官网](https://www.kancloud.cn/yunye/axios/234845)\n\n### axios 拦截器\n\n```js\n// myAxios.js\n// 添加请求拦截器\naxios.interceptors.request.use(\n  config => {\n    const token = localStorage.getItem(\'HAS_SET_TOKEN\')\n    if (token) {\n      // Bearer是JWT的认证头部信息\n      config.headers.common[\'Authorization\'] = \'Bearer \' + token\n    }\n    // 在发送请求前做些什么\n    return config\n  },\n  error => {\n    return Promise.reject(error)\n  }\n)\n// 添加响应拦截器\naxios.interceptors.response.use(\n  response => {\n    // 在响应前做些什么\n    return response\n  },\n  error => {\n    return Promise.reject(error)\n  }\n)\n```\n\n### 在网页中使用\n\n```js\nimport http from \'common/scripts/myAxios\'\nimport axios from \'axios\'\nhttp.customAxios().then(\n  res => {\n    console.log(\'myAxios\', res)\n  },\n  err => {\n    console.log(err)\n  }\n)\nconst url = \'https://cnodejs.org/api/v1/topics?page=1&tab=ask&limit=10&mdrender=true\'\naxios.get(url).then(\n  res => {\n    console.log(\'axios\', res)\n  },\n  err => {\n    console.log(err)\n  }\n)\n```\n', '18', 'PUBLISHED', '', '2019-03-09 17:27:53', '0');
INSERT INTO `post` VALUES ('41', 'animation 与 transition 的区别', '## animation 与 transition 的区别\n\n> 作为移动端开发，css3 动画是基本功之一，在工作中难免遇到动画相关，那就必须先得搞懂 animation 和 transition 的区别\n\n- animation 的属性\n  1. animation-name keyframe 的名称\n  2. animation-duration 完成 keyframe 的花时间 单位是秒\n  3. animation-timing-function 动画的曲线 有 linear ease ease-in ease-out ease-in-out cubic-bezier(n,n,n,n)\n  4. animation-delay keyframe 执行前的延迟时间\n  5. animation-iteration-count 动画执行的次数 n 与 infinite（无限循环）\n  6. animation-direction 是否轮流播放动画 normal 与 alternate(0-1-1-0 式播放)\n  7. animation-fill-mode forwards 停留在结束状态 backwards 让动画回到第一帧的状态 both 设置动画结束时的状态，以结束时动画的状态优先\n- transition 的属性\n  1. transition-property 在哪个 css 属性变化时执行 transition\n  2. transition-duration 执行 transition 的时长 单位秒\n  3. transition-timing-function 动画的曲线 linear ease ease-in ease-out ease-in-out cubic-bezier(n,n,n,n)\n  4. transition-delay 延迟多长后时间执行 单位秒\n- transition 与 animation 的区别\n  - transition\n    1. 需要事件触发，比如点击时添加一个有 transition 的 class\n    2. 一次性的，只执行一次，除非写一个多少秒执行的 setInterval\n    3. 只能定义开始和结束状态\n    4. 只能设计一个属性变化\n    5. 用户的最终状态停留在有 transition 的 class\n    6. disiplay：none 到 display：block 不会产生动画效果\n  - animation\n    1. 不需要事件触发\n    2. 可以多次执行或者循环执行\n    3. 可以定义多帧的状态\n    4. 可以设置多个属性状态变化\n    5. 可以设定停止在哪个状态\n- 片段代码\n\n```css\n.box {\n  width: 100px;\n  height: 100px;\n  background: #555;\n  -webkit-animation: fly 1s linear 1s 3 alternate both;\n}\n\n@-webkit-keyframes fly {\n  0% {\n    -webkit-transform: translateX(0);\n  }\n\n  50% {\n    -webkit-transform: translateX(40px);\n  }\n\n  100% {\n    -webkit-transform: translateX(100px);\n  }\n}\n\n#box2 {\n  width: 100px;\n  height: 100px;\n  background: #555;\n}\n\n.fadeOut {\n  opacity: 0;\n  transition: opacity 1s ease;\n}\n```\n\n```html\n<div class=\"box\" id=\"box\"></div>\n<div id=\"box2\"></div>\n<script>\n  document.getElementById(\'box\').onclick = function() {\n    document.getElementById(\'box2\').className = \'fadeOut\'\n  }\n</script>\n```\n\n- 总结\n  - animation 和 transition 的是 css3 属性，所以再设置的时候要加上兼容头，具体的细节可以看[MDN](https://developer.mozilla.org/zh-CN/docs/Web/CSS/animation) 贝塞尔曲线可以使用[工具](http://cubic-bezier.com/#.17,.67,.83,.67)\n', '19', 'PUBLISHED', '', '2019-03-09 17:28:34', '0');

-- ----------------------------
-- Table structure for post_tag
-- ----------------------------
DROP TABLE IF EXISTS `post_tag`;
CREATE TABLE `post_tag` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `postId` int(11) NOT NULL COMMENT '文章表主键',
  `tagId` int(11) NOT NULL COMMENT '标签表主键',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=173 DEFAULT CHARSET=utf8 COMMENT='文章-标签对应表';

-- ----------------------------
-- Records of post_tag
-- ----------------------------
INSERT INTO `post_tag` VALUES ('154', '30', '48');
INSERT INTO `post_tag` VALUES ('155', '30', '49');
INSERT INTO `post_tag` VALUES ('156', '30', '50');
INSERT INTO `post_tag` VALUES ('157', '33', '51');
INSERT INTO `post_tag` VALUES ('158', '34', '52');
INSERT INTO `post_tag` VALUES ('159', '34', '53');
INSERT INTO `post_tag` VALUES ('160', '35', '54');
INSERT INTO `post_tag` VALUES ('161', '36', '53');
INSERT INTO `post_tag` VALUES ('162', '36', '48');
INSERT INTO `post_tag` VALUES ('163', '36', '55');
INSERT INTO `post_tag` VALUES ('164', '36', '56');
INSERT INTO `post_tag` VALUES ('165', '37', '57');
INSERT INTO `post_tag` VALUES ('166', '38', '55');
INSERT INTO `post_tag` VALUES ('167', '39', '53');
INSERT INTO `post_tag` VALUES ('168', '39', '58');
INSERT INTO `post_tag` VALUES ('169', '40', '59');
INSERT INTO `post_tag` VALUES ('170', '40', '60');
INSERT INTO `post_tag` VALUES ('171', '41', '61');
INSERT INTO `post_tag` VALUES ('172', '41', '62');

-- ----------------------------
-- Table structure for tag
-- ----------------------------
DROP TABLE IF EXISTS `tag`;
CREATE TABLE `tag` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(100) DEFAULT NULL COMMENT '标签名称',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=63 DEFAULT CHARSET=utf8 COMMENT='标签表';

-- ----------------------------
-- Records of tag
-- ----------------------------
INSERT INTO `tag` VALUES ('48', 'koa');
INSERT INTO `tag` VALUES ('49', 'koa-static');
INSERT INTO `tag` VALUES ('50', 'koa-router');
INSERT INTO `tag` VALUES ('51', 'jwt');
INSERT INTO `tag` VALUES ('52', 'mysql');
INSERT INTO `tag` VALUES ('53', 'nodejs');
INSERT INTO `tag` VALUES ('54', 'redis');
INSERT INTO `tag` VALUES ('55', 'vuejs');
INSERT INTO `tag` VALUES ('56', 'socket');
INSERT INTO `tag` VALUES ('57', 'vue-rotuer');
INSERT INTO `tag` VALUES ('58', 'promise');
INSERT INTO `tag` VALUES ('59', '拦截器');
INSERT INTO `tag` VALUES ('60', 'axios');
INSERT INTO `tag` VALUES ('61', 'animation');
INSERT INTO `tag` VALUES ('62', 'transition');

-- ----------------------------
-- Table structure for user
-- ----------------------------
DROP TABLE IF EXISTS `user`;
CREATE TABLE `user` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `userName` varchar(50) DEFAULT NULL COMMENT '用户名',
  `hashedPassword` varchar(1024) DEFAULT NULL COMMENT '加密后的密码',
  `salt` varchar(128) DEFAULT NULL COMMENT '加密的盐',
  `avatar` varchar(500) DEFAULT NULL COMMENT '用户头像',
  `role` enum('ADMIN','GUEST') DEFAULT NULL COMMENT '用户角色（ADMIN:管理员，GUEST:游客）',
  `createTime` datetime DEFAULT NULL COMMENT '创建时间',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=43 DEFAULT CHARSET=utf8 COMMENT='用户表';

-- ----------------------------
-- Records of user
-- ----------------------------
INSERT INTO `user` VALUES ('42', 'admin', 'f6FVVbJZ7rXxIyuzeGJC2nRsTxGhe1ea29mlWsSqYSif9vriyYJJhlXywOHXWVhKkIUIZua5HMKBVekT2dbQiQ==', '8Zv87QHnIMdcgP8FgknyLw==', null, 'ADMIN', '2019-03-09 17:16:20');
